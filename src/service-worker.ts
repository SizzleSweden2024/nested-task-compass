/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Use clientsClaim() to take control of all pages immediately
clientsClaim();

// Precache all assets generated by the build process
const manifest = self.__WB_MANIFEST;
precacheAndRoute(manifest);

// Set up App Shell-style routing for SPA
const fileExtensionRegexp = /\.[^/]+$/;
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html
  ({ request, url }: { request: Request; url: URL }) => {
    // If this is a navigation request, skip handling
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a file (has extension), skip
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want this to be handled by the SPA
    return true;
  },
  createHandlerBoundToURL('/index.html')
);

// Cache images with a Cache First strategy for longer period
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      // Ensure we don't keep more than 60 images in the cache
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache CSS and JS with a Stale While Revalidate strategy
registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 32,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
      }),
    ],
  })
);

// Cache font files
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 10,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache API requests with a Network First strategy
registerRoute(
  ({ url }) => url.pathname.includes('/api/'),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// Handle notification click events
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  // Focus on or open a window when notification is clicked
  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clientList) => {
      for (const client of clientList) {
        if (client.url === '/' && 'focus' in client) {
          return client.focus();
        }
      }
      if (self.clients.openWindow) {
        return self.clients.openWindow('/');
      }
    })
  );
});

// Handle background sync for offline data
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-tasks') {
    event.waitUntil(syncTasks());
  }
});

async function syncTasks() {
  try {
    const cache = await caches.open('offline-tasks');
    const requests = await cache.keys();
    
    const syncPromises = requests.map(async (request) => {
      const response = await cache.match(request);
      if (!response) return;
      
      const data = await response.json();
      
      // Attempt to send the data to the server
      try {
        const serverResponse = await fetch(request.url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data),
        });
        
        if (serverResponse.ok) {
          // If successful, remove from offline cache
          await cache.delete(request);
        }
      } catch (error) {
        console.error('Failed to sync task:', error);
      }
    });
    
    await Promise.all(syncPromises);
  } catch (error) {
    console.error('Error during task synchronization:', error);
  }
}

// When a fetch fails during offline mode, respond with custom offline page
const offlineResponse = new Response(
  '<html><head><title>Offline</title><style>body{font-family:sans-serif;text-align:center;padding:20px;}h1{color:#f97316;}</style></head><body><h1>You are offline</h1><p>But don\'t worry! You can still use Khonja and your changes will be synced when you\'re back online.</p></body></html>',
  {
    headers: { 'Content-Type': 'text/html' },
  }
);

self.addEventListener('fetch', (event) => {
  // Let Workbox handle most of the routing
  if (event.request.mode === 'navigate' && !navigator.onLine) {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/offline.html') || Promise.resolve(offlineResponse);
      })
    );
  }
});

// Listen for the 'message' event to handle cache updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
